# 新媒体类型系统设计

## 概述

实现一个新的媒体类型系统，允许：
1. 定义不同类型的媒体（STANDARD 和 SPECIAL）
2. 不同物品提供不同类型的媒体
3. 某些动作只能消耗特定类型的媒体
4. 如果特定类型媒体不足，消耗血量
5. 不同类型的媒体不能互相存储

## 架构设计

### 1. 核心接口和类

#### MediaType (枚举)
- `STANDARD`: 普通媒体类型（HexMod 原有）
- `SPECIAL`: 特殊媒体类型（新类型）

#### TypedMediaHolder (接口)
扩展 `ADMediaHolder`，增加媒体类型支持：
- `getMediaType()`: 获取媒体类型
- `canStoreMediaType(MediaType)`: 检查是否可以存储
- `canProvideMediaType(MediaType)`: 检查是否可以提供

#### MediaTypeRegistry (注册表)
管理物品和动作的媒体类型映射：
- 物品 → 媒体类型
- 动作 → 需要的媒体类型

### 2. 实现步骤

#### 步骤 1: 创建类型化媒体容器

需要创建：
- `TypedMediaHolderItem` 接口（类似 `MediaHolderItem`）
- `TypedStaticMediaHolder` 实现（用于消耗品）
- `TypedMediaContainerHolder` 实现（用于容器）

#### 步骤 2: 修改媒体提取逻辑（Mixin）

需要 Mixin 到：
- `CastingEnvironment.extractMediaEnvironment()`
- 修改媒体查找逻辑，按类型查找
- 如果特定类型不足，消耗血量

#### 步骤 3: 注册系统

在 `DCoreMediaComponents` 中：
- 注册消耗品的媒体类型
- 注册容器的媒体类型
- 注册动作需要的媒体类型

#### 步骤 4: 配置系统

创建 JSON 配置文件来定义：
- 哪些物品提供特殊媒体
- 哪些动作需要特殊媒体

## 实现细节

### Mixin 策略

需要 Mixin 到媒体提取的核心逻辑，这可能需要：
1. Mixin 到 `CastingEnvironment` 的实现类
2. 或者使用 `CastingEnvironmentComponent.ExtractMedia` hook

### 媒体查找流程

1. 检查动作是否需要特定类型媒体
2. 如果需要，先查找该类型的媒体源
3. 如果不足，消耗血量
4. 如果不需要特定类型，使用原有逻辑

### 容器隔离

不同类型的媒体容器：
- 不能互相存储（`canStoreMediaType` 检查）
- `insertMedia` 时检查类型兼容性
- `withdrawMedia` 时只提供对应类型

## 配置示例

```json
{
  "special_media_items": {
    "spectrum:amethyst_powder": {
      "amount": 80000,
      "type": "special"
    }
  },
  "special_media_actions": [
    "d-core:my_action"
  ]
}
```

