# 新媒体类型系统实现指南

## 已完成的基础框架

1. ✅ `MediaType.java` - 媒体类型枚举（STANDARD, SPECIAL）
2. ✅ `TypedMediaHolder.java` - 类型化媒体容器接口
3. ✅ `MediaTypeRegistry.java` - 媒体类型注册表
4. ✅ `TypedMediaExtractor.java` - 媒体提取组件（需要完善）

## 需要完成的部分

### 1. 获取当前动作 ID

在 `TypedMediaExtractor.getCurrentActionId()` 中，需要从执行上下文获取当前动作。

**可能的方案：**
- Mixin 到动作执行代码，传递动作 ID 到环境
- 使用线程局部变量存储当前动作
- 从 CastingImage 或其他执行上下文获取

**需要研究 HexMod 的执行流程来确定最佳方案**

### 2. 创建类型化媒体容器实现

#### Fabric 实现
创建 `TypedCCMediaHolder`：
- 扩展 `CCMediaHolder`
- 实现 `TypedMediaHolder` 接口
- 支持 Static（消耗品）和 ItemBased（容器）两种模式

### 3. 注册系统集成

在 `DCoreMediaComponents` 中：
1. 注册消耗品时指定媒体类型
2. 注册容器时指定媒体类型
3. 注册 ExtractMedia 组件到环境

### 4. 配置系统

创建 JSON 配置文件来定义：
- 哪些物品提供特殊媒体
- 哪些动作需要特殊媒体

### 5. 血量转换计算

根据 HexMod 的配置计算血量到媒体的转换率。

## 实现步骤

### 步骤 1: 完善 TypedMediaExtractor

需要解决如何获取当前动作 ID 的问题。

### 步骤 2: 创建类型化容器实现

类似 `CCMediaHolder`，但支持类型。

### 步骤 3: 修改注册逻辑

在 `DCoreMediaComponents` 中注册类型化容器。

### 步骤 4: 添加配置支持

创建配置文件加载系统。

## 注意事项

1. **兼容性**: 确保原有媒体系统仍然工作
2. **性能**: 媒体查找不应该影响性能
3. **错误处理**: 妥善处理类型不匹配的情况

## 测试要点

1. 消耗品是否能正确提供指定类型媒体
2. 容器是否能正确存储和提取指定类型媒体
3. 动作是否能正确消耗指定类型媒体
4. 血量消耗是否在媒体不足时正确触发
5. 类型隔离是否正常工作（不能混存）

